package types

import (
	"context"
	"fmt"
	"time"
)

// Mission represents a high-level goal that gets broken down into phases
// Missions are the "outer loop" in the three-tier workflow:
//   OUTER: Mission (top-level goal)
//   MIDDLE: Phases (implementation plan broken into stages)
//   INNER: Tasks (granular work items within each phase)
type Mission struct {
	Issue              // Embed base Issue type
	Goal        string `json:"goal"`         // High-level goal description
	Context     string `json:"context"`      // Additional context for planning
	PhaseCount  int    `json:"phase_count"`  // Number of phases in the plan
	CurrentPhase int   `json:"current_phase"` // Current phase being executed (0-indexed)
	ApprovalRequired bool `json:"approval_required"` // Requires human approval before execution
	ApprovedAt  *time.Time `json:"approved_at,omitempty"` // When plan was approved
	ApprovedBy  string `json:"approved_by,omitempty"`    // Who approved the plan
	SandboxPath string `json:"sandbox_path,omitempty"`    // Path to sandbox directory for this mission
	BranchName  string `json:"branch_name,omitempty"`     // Git branch for this mission's work
	IterationCount int `json:"iteration_count"`           // Number of execution iterations
	GatesStatus string `json:"gates_status,omitempty"`    // Quality gates status (passed/failed)
}

// Validate checks if the mission has valid field values
func (m *Mission) Validate() error {
	// Validate embedded Issue
	if err := m.Issue.Validate(); err != nil {
		return fmt.Errorf("invalid issue: %w", err)
	}

	// Mission-specific validation
	if m.IssueType != TypeEpic {
		return fmt.Errorf("mission must be of type epic (got %s)", m.IssueType)
	}
	if m.Goal == "" {
		return fmt.Errorf("goal is required")
	}
	if m.PhaseCount < 0 {
		return fmt.Errorf("phase_count cannot be negative (got %d)", m.PhaseCount)
	}
	if m.CurrentPhase < 0 {
		return fmt.Errorf("current_phase cannot be negative (got %d)", m.CurrentPhase)
	}
	if m.CurrentPhase > m.PhaseCount {
		return fmt.Errorf("current_phase (%d) cannot exceed phase_count (%d)", m.CurrentPhase, m.PhaseCount)
	}
	if m.ApprovalRequired && m.ApprovedAt != nil && m.ApprovedBy == "" {
		return fmt.Errorf("approved_by is required when approved_at is set")
	}

	return nil
}

// IsApproved returns true if the mission plan has been approved (or doesn't require approval)
func (m *Mission) IsApproved() bool {
	if !m.ApprovalRequired {
		return true
	}
	return m.ApprovedAt != nil
}

// Phase represents a major stage in a mission implementation
// Each phase is created as a child epic of the mission with its own tasks
type Phase struct {
	Issue               // Embed base Issue type
	MissionID   string  `json:"mission_id"`    // Parent mission ID
	PhaseNumber int     `json:"phase_number"`  // Phase number in the mission (1-indexed for display)
	Strategy    string  `json:"strategy"`      // High-level strategy for this phase
	Dependencies []string `json:"dependencies"` // Other phase IDs this depends on
	SandboxBranch string `json:"sandbox_branch,omitempty"` // Git branch for this phase's work
}

// Validate checks if the phase has valid field values
func (p *Phase) Validate() error {
	// Validate embedded Issue
	if err := p.Issue.Validate(); err != nil {
		return fmt.Errorf("invalid issue: %w", err)
	}

	// Phase-specific validation
	if p.IssueType != TypeEpic {
		return fmt.Errorf("phase must be of type epic (got %s)", p.IssueType)
	}
	if p.MissionID == "" {
		return fmt.Errorf("mission_id is required")
	}
	if p.PhaseNumber < 1 {
		return fmt.Errorf("phase_number must be positive (got %d)", p.PhaseNumber)
	}
	if p.Strategy == "" {
		return fmt.Errorf("strategy is required")
	}

	return nil
}

// MissionPlan represents a complete plan generated by the AI planner
type MissionPlan struct {
	MissionID    string          `json:"mission_id"`
	Phases       []PlannedPhase  `json:"phases"`       // Ordered list of phases
	Strategy     string          `json:"strategy"`     // Overall implementation strategy
	Risks        []string        `json:"risks"`        // Potential risks or challenges
	EstimatedEffort string       `json:"estimated_effort"` // e.g., "2 days", "1 week"
	Confidence   float64         `json:"confidence"`   // Confidence score (0.0-1.0)
	GeneratedAt  time.Time       `json:"generated_at"` // When the plan was generated
	GeneratedBy  string          `json:"generated_by"` // Who/what generated the plan (e.g., "ai-planner")
	Status       string          `json:"status"`       // Plan status: "draft", "refining", "validated", "approved"
}

// Validate checks if the mission plan has valid field values
func (p *MissionPlan) Validate() error {
	if p.MissionID == "" {
		return fmt.Errorf("mission_id is required")
	}
	if len(p.Phases) == 0 {
		return fmt.Errorf("plan must have at least one phase")
	}
	if p.Strategy == "" {
		return fmt.Errorf("strategy is required")
	}
	if p.Confidence < 0.0 || p.Confidence > 1.0 {
		return fmt.Errorf("confidence must be between 0.0 and 1.0 (got %.2f)", p.Confidence)
	}
	if p.EstimatedEffort == "" {
		return fmt.Errorf("estimated_effort is required")
	}

	// Validate each phase
	for i, phase := range p.Phases {
		if err := phase.Validate(); err != nil {
			return fmt.Errorf("invalid phase %d: %w", i+1, err)
		}
		// Phase numbers should be sequential starting at 1
		if phase.PhaseNumber != i+1 {
			return fmt.Errorf("phase %d has incorrect phase_number (expected %d, got %d)", i+1, i+1, phase.PhaseNumber)
		}
	}

	return nil
}

// PlannedPhase represents a phase in a generated mission plan
// This is what the AI planner outputs before phases are created as issues
type PlannedPhase struct {
	PhaseNumber  int      `json:"phase_number"`  // Phase number (1-indexed)
	Title        string   `json:"title"`         // Phase title
	Description  string   `json:"description"`   // Detailed description
	Strategy     string   `json:"strategy"`      // Strategy for this phase
	Tasks        []string `json:"tasks"`         // High-level task descriptions
	Dependencies []int    `json:"dependencies"`  // Phase numbers this depends on
	EstimatedEffort string `json:"estimated_effort"` // e.g., "4 hours", "1 day"
}

// Validate checks if the planned phase has valid field values
func (p *PlannedPhase) Validate() error {
	if p.PhaseNumber < 1 {
		return fmt.Errorf("phase_number must be positive (got %d)", p.PhaseNumber)
	}
	if p.Title == "" {
		return fmt.Errorf("title is required")
	}
	if p.Description == "" {
		return fmt.Errorf("description is required")
	}
	if p.Strategy == "" {
		return fmt.Errorf("strategy is required")
	}
	if len(p.Tasks) == 0 {
		return fmt.Errorf("phase must have at least one task")
	}
	if p.EstimatedEffort == "" {
		return fmt.Errorf("estimated_effort is required")
	}

	// Validate dependencies reference earlier phases
	for _, depPhaseNum := range p.Dependencies {
		if depPhaseNum >= p.PhaseNumber {
			return fmt.Errorf("phase %d cannot depend on phase %d (dependencies must be on earlier phases)", p.PhaseNumber, depPhaseNum)
		}
		if depPhaseNum < 1 {
			return fmt.Errorf("invalid dependency phase number: %d", depPhaseNum)
		}
	}

	return nil
}

// PlanningContext provides context for the AI planner when generating a mission plan
type PlanningContext struct {
	Mission      *Mission        `json:"mission"`       // The mission to plan
	CodebaseInfo string          `json:"codebase_info"` // Information about the codebase structure
	RecentIssues []*Issue        `json:"recent_issues"` // Recent issues for context
	FailedAttempts int           `json:"failed_attempts"` // Number of previous planning attempts that failed
	Constraints  []string        `json:"constraints"`    // Any constraints on the plan (e.g., "no breaking changes")
	Metadata     map[string]string `json:"metadata"`    // Additional context as key-value pairs
}

// Validate checks if the planning context has valid field values
func (c *PlanningContext) Validate() error {
	if c.Mission == nil {
		return fmt.Errorf("mission is required")
	}
	if err := c.Mission.Validate(); err != nil {
		return fmt.Errorf("invalid mission: %w", err)
	}
	if c.FailedAttempts < 0 {
		return fmt.Errorf("failed_attempts cannot be negative (got %d)", c.FailedAttempts)
	}

	return nil
}

// MissionContext provides mission metadata for a task
// Returned by GetMissionForTask() when walking dependency tree upward
type MissionContext struct {
	MissionID   string `json:"mission_id"`    // ID of the parent mission epic
	SandboxPath string `json:"sandbox_path"`  // Path to sandbox directory (future - vc-217)
	BranchName  string `json:"branch_name"`   // Git branch for this mission (future - vc-217)
}

// MissionPlanner is the interface for AI-driven mission planning
// Implementations use AI to break down high-level goals into phased implementation plans
type MissionPlanner interface {
	// GeneratePlan generates a phased implementation plan for a mission
	// Returns a MissionPlan with phases, strategy, risks, and confidence score
	GeneratePlan(ctx context.Context, planningCtx *PlanningContext) (*MissionPlan, error)

	// RefinePhase generates detailed task breakdown for a specific phase
	// This is called when a phase is ready to execute and needs granular tasks
	RefinePhase(ctx context.Context, phase *Phase, missionCtx *PlanningContext) ([]PlannedTask, error)

	// ValidatePlan checks if a generated plan is valid and executable
	// Returns error if plan has issues, nil if valid
	ValidatePlan(ctx context.Context, plan *MissionPlan) error

	// ValidatePhaseStructure validates phase dependencies and ordering
	// Returns error if phase structure is invalid (e.g., circular dependencies, invalid ordering)
	// This delegates validation logic to AI rather than using hardcoded rules
	ValidatePhaseStructure(ctx context.Context, phases []PlannedPhase) error
}

// PlannedTask represents a granular task within a phase
// These are generated when refining a phase into executable work items
type PlannedTask struct {
	Title              string   `json:"title"`
	Description        string   `json:"description"`
	AcceptanceCriteria string   `json:"acceptance_criteria"`
	Dependencies       []string `json:"dependencies"` // Titles of other tasks this depends on
	EstimatedMinutes   int      `json:"estimated_minutes"`
	Priority           int      `json:"priority"` // 0-3 (P0-P3)
	Type               string   `json:"type"`     // "task", "bug", "feature", etc.
}

// Validate checks if the planned task has valid field values
func (t *PlannedTask) Validate() error {
	if t.Title == "" {
		return fmt.Errorf("title is required")
	}
	if t.Description == "" {
		return fmt.Errorf("description is required")
	}
	if t.EstimatedMinutes < 0 {
		return fmt.Errorf("estimated_minutes cannot be negative (got %d)", t.EstimatedMinutes)
	}
	if t.Priority < 0 || t.Priority > 3 {
		return fmt.Errorf("priority must be between 0 and 3 (got %d)", t.Priority)
	}
	if t.Type == "" {
		return fmt.Errorf("type is required")
	}

	// Validate type is a valid IssueType
	issueType := IssueType(t.Type)
	if !issueType.IsValid() {
		return fmt.Errorf("invalid type: %s", t.Type)
	}

	return nil
}
